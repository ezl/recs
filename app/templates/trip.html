{% extends "base.html" %}

{% block title %}Recommendations for {{ trip.traveler_name }}'s Trip to {{ trip.destination }} | Recs{% endblock %}

{% block head_extras %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/pages/recommendations.css') }}">
{% endblock %}

{% block content %}
<div class="page-container py-10">
  <div class="mb-10">
    <h1 class="page-title">
      {{ trip.traveler_name }}, you're going to {{ trip.destination }}!
    </h1>
    
    <!-- Include share box component -->
    {% with 
      id = trip.id, 
      title = "Ask your friends for recommendations", 
      description = "Send this link to your friends or post it on social media to get recommendations!", 
      share_url = url_for('recommendation.add_recommendation', slug=trip.slug, _external=True) 
    %}
      {% include 'components/share_box.html' %}
    {% endwith %}
  </div>

  <!-- Include destination information card component -->
  {% include 'components/destination_info_card.html' %}

  {% if trip.recommendations %}
    <div class="mb-8">
      <div class="flex items-center justify-between mb-2">
        <h2 class="section-title">
          Recommendations for {{ trip.traveler_name }}
        </h2>
        <div class="flex items-center space-x-2">
          <!-- View toggle buttons -->
          <div class="flex border border-gray-200 rounded-md overflow-hidden mr-2">
            <button id="card-view-btn" class="inline-flex items-center px-3 py-1.5 bg-blue-100 text-blue-800 text-sm font-medium">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7" />
              </svg>
              Cards
            </button>
            <button id="map-view-btn" class="inline-flex items-center px-3 py-1.5 bg-white text-gray-600 hover:text-gray-900 text-sm font-medium">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4" />
              </svg>
              Map
            </button>
          </div>
          
          <!-- Include search controls component -->
          {% include 'components/trip/_search_controls.html' %}
          
          <button id="toggle-filters" class="inline-flex items-center px-2 py-1 text-gray-600 hover:text-gray-900 transition">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
              <path stroke-linecap="round" stroke-linejoin="round" d="M12 3c2.755 0 5.455.232 8.083.678.533.09.917.556.917 1.096v1.044a2.25 2.25 0 0 1-.659 1.591l-5.432 5.432a2.25 2.25 0 0 0-.659 1.591v2.927a2.25 2.25 0 0 1-1.244 2.013L9.75 21v-6.568a2.25 2.25 0 0 0-.659-1.591L3.659 7.409A2.25 2.25 0 0 1 3 5.818V4.774c0-.54.384-1.006.917-1.096A48.32 48.32 0 0 1 12 3Z" />
            </svg>
            <span class="ml-1">Filter</span>
          </button>
        </div>
      </div>
      
      <p class="text-gray-600 text-sm mb-4">
        {% set grouped_recommendations = trip.get_grouped_recommendations() %}
        {% set contributors = trip.get_contributors() %}
        {{ contributors|length }} contributors, {{ grouped_recommendations|length }} activities, {{ trip.recommendations|length }} recommendations
      </p>
      
      <!-- Include filter controls component -->
      {% include 'components/trip/_filter_controls.html' %}
      
      <!-- Card View Container -->
      <div id="card-view" class="grid md:grid-cols-2 gap-6">
        {% for group in grouped_recommendations %}
          {% include 'components/trip/_recommendation_card.html' %}
        {% endfor %}
      </div>
      
      <!-- Include map view component -->
      {% include 'components/trip/_map_view.html' %}
    </div>
  {% else %}
    <div class="card mb-8 bg-gray-50 text-center">
      <h2 class="text-xl font-semibold text-gray-700 mb-3">No recommendations yet</h2>
      <p class="text-gray-500 mt-10 mb-10">Your friends' recommendations will show up here</p>
    </div>
  {% endif %}
  
</div>
{% endblock %}

{% block scripts %}
<!-- Google Maps API Script -->
<script src="https://maps.googleapis.com/maps/api/js?key={{ config.GOOGLE_MAPS_API_KEY }}&callback=initMap" async defer></script>

<script>
  // Map initialization function (called by Google Maps API after loading)
  function initMap() {
    // This will be called when Google Maps API is loaded
    if (window.setupMap && typeof window.setupMap === 'function') {
      console.log('Setting up map...');
      window.setupMap();
    } else {
      console.warn('setupMap function not found when Google Maps API loaded');
    }
  }

  document.addEventListener('DOMContentLoaded', function() {
    // View toggle variables
    const cardViewBtn = document.getElementById('card-view-btn');
    const mapViewBtn = document.getElementById('map-view-btn');
    const cardView = document.getElementById('card-view');
    const mapView = document.getElementById('map-view');
    
    // Toggle view functions
    cardViewBtn.addEventListener('click', function() {
      // Show card view, hide map view
      cardView.classList.remove('hidden');
      mapView.classList.add('hidden');
      
      // Update button styles
      cardViewBtn.classList.remove('bg-white', 'text-gray-600');
      cardViewBtn.classList.add('bg-blue-100', 'text-blue-800');
      mapViewBtn.classList.remove('bg-blue-100', 'text-blue-800');
      mapViewBtn.classList.add('bg-white', 'text-gray-600');
    });
    
    mapViewBtn.addEventListener('click', function() {
      // Show map view, hide card view
      mapView.classList.remove('hidden');
      cardView.classList.add('hidden');
      
      // Update button styles
      mapViewBtn.classList.remove('bg-white', 'text-gray-600');
      mapViewBtn.classList.add('bg-blue-100', 'text-blue-800');
      cardViewBtn.classList.remove('bg-blue-100', 'text-blue-800');
      cardViewBtn.classList.add('bg-white', 'text-gray-600');
      
      // Trigger map resize event to ensure proper rendering
      if (window.google && window.google.maps && window.map) {
        google.maps.event.trigger(window.map, 'resize');
        centerMap();
      }
    });
    
    // Toggle filter section visibility
    const toggleFiltersBtn = document.getElementById('toggle-filters');
    const filterSection = document.getElementById('filter-section');
    
    toggleFiltersBtn.addEventListener('click', function() {
      filterSection.classList.toggle('hidden');
    });
    
    // Toggle search input visibility
    const toggleSearchBtn = document.getElementById('toggle-search');
    const searchInputContainer = document.getElementById('search-input-container');
    const searchInput = document.getElementById('search-input');
    
    toggleSearchBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      searchInputContainer.classList.toggle('hidden');
      if (!searchInputContainer.classList.contains('hidden')) {
        searchInput.focus();
      }
    });
    
    // Close search when clicking outside
    document.addEventListener('click', function(e) {
      if (!searchInputContainer.contains(e.target) && e.target !== toggleSearchBtn) {
        searchInputContainer.classList.add('hidden');
      }
    });
    
    // Search functionality
    searchInput.addEventListener('input', function() {
      const searchTerm = this.value.trim().toLowerCase();
      
      // Remove all highlights first regardless of search term length
      document.querySelectorAll('.recommendation-card').forEach(card => {
        removeHighlights(card);
      });
      
      // If search term is empty, show all cards and stop
      if (searchTerm === '') {
        document.querySelectorAll('.recommendation-card').forEach(card => {
          card.classList.remove('search-hidden');
        });
        return;
      }
      
      // Only filter if searchTerm has 3 or more characters
      if (searchTerm.length >= 3) {
        searchCards(searchTerm);
      } else {
        // Show all cards if search term is too short
        document.querySelectorAll('.recommendation-card').forEach(card => {
          card.classList.remove('search-hidden');
        });
      }
    });
    
    function searchCards(searchTerm) {
      const cards = document.querySelectorAll('.recommendation-card');
      
      cards.forEach(card => {
        // Get all searchable content from the card
        const cardTitle = card.querySelector('h3').textContent.toLowerCase();
        const categoryElem = card.querySelector('.badge');
        const category = categoryElem ? categoryElem.textContent.toLowerCase() : '';
        
        // Get all recommendation texts
        const recommendationTexts = Array.from(card.querySelectorAll('.text-gray-600')).map(el => el.textContent.toLowerCase());
        
        // Get all contributor names - look in both structures
        // For multiple recommenders, names are in .text-sm.font-medium
        const contributorNamesMultiple = Array.from(card.querySelectorAll('.text-sm.font-medium')).map(el => el.textContent.toLowerCase());
        
        // For single recommender, name is in .text-gray-500.text-sm.mb-2
        const singleRecommenderElem = card.querySelector('.text-gray-500.text-sm.mb-2');
        const singleRecommenderText = singleRecommenderElem ? singleRecommenderElem.textContent.toLowerCase() : '';
        
        // Combine all possible sources of contributor names
        const allTexts = [
          cardTitle,
          category,
          ...recommendationTexts,
          ...contributorNamesMultiple,
          singleRecommenderText
        ].filter(Boolean); // Remove empty strings
        
        // Check if any text contains the search term
        const hasMatch = allTexts.some(text => text.includes(searchTerm));
        
        // If any match, show the card and highlight the matched text
        if (hasMatch) {
          card.classList.remove('search-hidden');
          
          // Highlight matches
          removeHighlights(card);
          highlightMatches(card, searchTerm);
        } else {
          card.classList.add('search-hidden');
          removeHighlights(card);
        }
      });
    }
    
    function highlightMatches(card, searchTerm) {
      const elementsToSearch = [
        ...card.querySelectorAll('h3'), // Title
        ...card.querySelectorAll('.badge'), // Category
        ...card.querySelectorAll('.text-gray-600'), // Recommendation texts
        ...card.querySelectorAll('.text-sm.font-medium'), // Contributor names (multiple)
        ...card.querySelectorAll('.text-gray-500.text-sm.mb-2') // "Recommended by" text (single)
      ];
      
      elementsToSearch.forEach(element => {
        const originalText = element.textContent;
        const lowerText = originalText.toLowerCase();
        
        // Simple case-insensitive match for highlighting
        if (lowerText.includes(searchTerm.toLowerCase())) {
          let newHtml = '';
          let lastIndex = 0;
          let index = lowerText.indexOf(searchTerm.toLowerCase());
          
          // Find all occurrences of the search term
          while (index !== -1) {
            // Add the text before the match
            newHtml += originalText.substring(lastIndex, index);
            
            // Add the highlighted match
            const match = originalText.substring(index, index + searchTerm.length);
            newHtml += `<mark class="bg-yellow-300 px-0.5 rounded">${match}</mark>`;
            
            // Move to the next match
            lastIndex = index + searchTerm.length;
            index = lowerText.indexOf(searchTerm.toLowerCase(), lastIndex);
          }
          
          // Add the remaining text
          newHtml += originalText.substring(lastIndex);
          
          element.innerHTML = newHtml;
        }
      });
    }
    
    function removeHighlights(card) {
      // Get all mark elements within the card
      const highlightedElements = card.querySelectorAll('mark');
      
      highlightedElements.forEach(el => {
        // Replace the mark with its text content
        const textNode = document.createTextNode(el.textContent);
        if (el.parentNode) {
          el.parentNode.replaceChild(textNode, el);
        }
      });
      
      // Clean up any potential empty elements created during the process
      card.normalize();
    }
    
    // Keep track of active filters
    const activeFilters = {
      contributor: new Set(),
      category: new Set()
    };

    // Initially set all filters as active
    document.querySelectorAll('[data-filter-type]').forEach(pill => {
      const filterType = pill.dataset.filterType;
      const filterValue = pill.dataset.filterValue;
      activeFilters[filterType].add(filterValue);
    });
    
    // Toggle filter pills
    document.querySelectorAll('[data-filter-type]').forEach(pill => {
      pill.addEventListener('click', function() {
        const filterType = this.dataset.filterType;
        const filterValue = this.dataset.filterValue;
        
        // Toggle pill appearance
        if (this.classList.contains('active')) {
          // Deactivate
          this.classList.remove('bg-blue-100', 'text-blue-800', 'border-blue-200', 'active');
          this.classList.add('bg-gray-100', 'text-gray-700', 'border-gray-200');
          activeFilters[filterType].delete(filterValue);
        } else {
          // Activate
          this.classList.remove('bg-gray-100', 'text-gray-700', 'border-gray-200');
          this.classList.add('bg-blue-100', 'text-blue-800', 'border-blue-200', 'active');
          activeFilters[filterType].add(filterValue);
        }
        
        // Apply filters to cards and map markers
        applyFilters();
      });
    });
    
    // Function to apply filters to recommendation cards and map markers
    function applyFilters() {
      const cards = document.querySelectorAll('.recommendation-card');
      const markers = window.mapMarkers || [];
      
      cards.forEach(card => {
        const cardCategory = card.dataset.category;
        const cardContributors = card.dataset.contributors.split(',');
        
        // Check if no filters are active for a type (show all)
        const noCategoryFilters = activeFilters.category.size === 0;
        const noContributorFilters = activeFilters.contributor.size === 0;
        
        // Check if card should be visible based on category filter
        const categoryMatch = 
          noCategoryFilters || 
          (cardCategory && activeFilters.category.has(cardCategory));
        
        // Check if card should be visible based on contributor filter
        const contributorMatch = 
          noContributorFilters || 
          cardContributors.some(id => activeFilters.contributor.has(id));
        
        // Show/hide card based on filter matches
        if (categoryMatch && contributorMatch) {
          card.classList.remove('hidden');
        } else {
          card.classList.add('hidden');
        }
        
        // Find and update corresponding map marker visibility
        if (window.map && markers.length > 0) {
          const activityId = card.dataset.activityId;
          const marker = markers.find(m => m.activityId === activityId);
          if (marker) {
            marker.setVisible(categoryMatch && contributorMatch);
          }
        }
      });
      
      // Update map bounds after filtering
      if (window.centerMap) {
        window.centerMap();
      }
    }
    
    // Map setup function - will be called when the Google Maps API is loaded
    window.mapMarkers = [];
    window.infoWindows = [];
    
    window.setupMap = function() {
      const recommendationsMap = document.getElementById('recommendations-map');
      if (!recommendationsMap) {
        return;
      }
      
      const cards = document.querySelectorAll('.recommendation-card');
      
      // Extract location data
      const locations = [];
      const missingLocations = [];
      
      cards.forEach(card => {
        const lat = parseFloat(card.dataset.lat);
        const lng = parseFloat(card.dataset.lng);
        const name = card.dataset.name;
        
        // Only add locations with valid coordinates
        if (!isNaN(lat) && !isNaN(lng) && lat !== 0 && lng !== 0) {
          locations.push({
            lat,
            lng,
            name,
            activityId: card.dataset.activityId,
            category: card.dataset.category,
            placeId: card.dataset.placeId,
            element: card
          });
        } else {
          // Track missing locations
          missingLocations.push(name);
        }
      });
      
      // Show missing coordinates message if needed
      const missingCoordinatesMessage = document.getElementById('missing-coordinates-message');
      const missingCoordinatesList = document.getElementById('missing-coordinates-list');
      
      if (missingLocations.length > 0) {
        // Clear previous list
        missingCoordinatesList.innerHTML = '';
        
        // Add each missing location to the list
        missingLocations.forEach(name => {
          const listItem = document.createElement('li');
          listItem.textContent = name;
          missingCoordinatesList.appendChild(listItem);
        });
        
        // Show the message
        missingCoordinatesMessage.classList.remove('hidden');
      } else {
        // Hide the message if no missing locations
        missingCoordinatesMessage.classList.add('hidden');
      }
      
      if (locations.length === 0) {
        // If no valid locations, show message in map container
        recommendationsMap.innerHTML = '<div class="flex h-full items-center justify-center"><p class="text-gray-500">No location data available for these recommendations</p></div>';
        return;
      }
      
      // Calculate average center point if multiple locations
      let centerLat = 0;
      let centerLng = 0;
      
      locations.forEach(loc => {
        centerLat += loc.lat;
        centerLng += loc.lng;
      });
      
      centerLat /= locations.length;
      centerLng /= locations.length;
      
      // Create the map
      window.map = new google.maps.Map(recommendationsMap, {
        center: { lat: centerLat, lng: centerLng },
        zoom: 12,
        mapTypeControl: true,
        fullscreenControl: true
      });
      
      // Create info window for marker click events
      const infoWindow = new google.maps.InfoWindow();
      
      // Create markers for each location
      locations.forEach(location => {
        const marker = new google.maps.Marker({
          position: { lat: location.lat, lng: location.lng },
          map: window.map,
          title: location.name,
          activityId: location.activityId,
          animation: google.maps.Animation.DROP
        });
        
        // Store marker reference for filtering
        window.mapMarkers.push(marker);
        
        // Add click event to marker
        marker.addListener('click', () => {
          // Scroll to corresponding card in the card view
          const card = location.element;
          if (card) {
            // Update info panel
            const infoPanel = document.getElementById('map-info-panel');
            const infoTitle = document.getElementById('map-info-title');
            const infoCategory = document.getElementById('map-info-category');
            const infoContent = document.getElementById('map-info-content');
            
            // Set info panel content
            infoTitle.textContent = location.name;
            
            // Add category badge if available
            if (location.category) {
              infoCategory.innerHTML = `<span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-blue-100 text-blue-800">${location.category}</span>`;
            } else {
              infoCategory.innerHTML = '';
            }
            
            // Add recommendation descriptions
            const descriptions = Array.from(card.querySelectorAll('.text-gray-600')).map(el => el.textContent);
            if (descriptions.length > 0) {
              infoContent.textContent = descriptions[0]; // Show first description
            } else {
              infoContent.textContent = 'No description available';
            }
            
            // Show the info panel
            infoPanel.classList.remove('hidden');
          }
          
          // Open Google Maps info window
          infoWindow.setContent(`
            <div class="p-2">
              <h3 class="font-semibold">${location.name}</h3>
              ${location.category ? `<p class="text-sm text-gray-600">${location.category}</p>` : ''}
              ${location.placeId ? `<a href="https://www.google.com/maps/place/?q=place_id:${location.placeId}" target="_blank" class="text-blue-600 text-sm hover:underline">View on Google Maps</a>` : ''}
            </div>
          `);
          infoWindow.open(window.map, marker);
        });
      });
      
      // Center map function
      window.centerMap = function() {
        if (window.map && locations.length > 0) {
          // Find visible markers based on active filters
          const visibleMarkers = window.mapMarkers.filter(marker => marker.getVisible());
          
          if (visibleMarkers.length > 0) {
            const bounds = new google.maps.LatLngBounds();
            visibleMarkers.forEach(marker => {
              bounds.extend(marker.getPosition());
            });
            window.map.fitBounds(bounds);
            
            // Adjust zoom level if there's only one marker
            if (visibleMarkers.length === 1) {
              window.map.setZoom(15);
            }
          }
        }
      };
      
      // Initial centering
      window.centerMap();
    };
  });
</script>

<style>
  .search-hidden {
    display: none;
  }
</style>
{% endblock %} 